# ドメイン駆動設計（DDD）とユビキタス言語による設計ポリシー

## 1. ドメイン駆動設計（DDD）とは

ドメイン駆動設計（Domain-Driven
Design、DDD）とは、エリック・エヴァンスによって2003年に著書「Domain-Driven
Design: Tackling Complexity in the Heart of
Software」で提唱されたソフトウェア開発手法です。DDDはその名の通り、「ドメイン」の知識にフォーカスした設計手法であり、システムを開発する際にビジネスドメインを正確にモデル化し、ソフトウェアの設計や実装に反映させることを目指します。

### 1.1 DDDの定義

**ドメイン駆動設計（DDD）**とは、ソフトウェア開発において、ビジネス上の重要な概念（ドメイン）を中心に据えて設計・実装を行う手法です。従来の「画面や機能を先に考える」アプローチとは異なり、まずはビジネスの本質や複雑な要件（＝ドメイン）を深く理解し、そのモデル（＝ドメインモデル）を開発者とビジネス担当者が共有言語で作り上げることが特徴です。

### 1.2 DDDの中心となる考え方

DDDの中心となる考え方は以下の3つに集約されます：

1. **ドメインモデルは、ドメイン知識を積み重ねながら漸進的に（iterative）に構築していく**
2. **ドメインモデルが、開発者とドメイン知識を持つ人（ユーザ、業務担当者）との間の共通言語となるようにする**
3. **ドメインモデルと実装コードとを常に対応づけておくようにする**

### 1.3 ドメインとは

**ドメイン**とは、「ソフトウェアを使って問題解決しようとしている領域」や「プログラムを適用する対象となる業務領域」などを指します。具体的には、会計システムにおける「金銭」や「振込処理」、SNSにおける「投稿」や「ユーザー」などが該当します。

### 1.4 なぜDDDが重要か

DDDが重要な理由は以下の通りです：

1. **要件の誤解を減らせる**
   - ユビキタス言語によって、ユーザーと開発者が同じ言葉でコミュニケーションが可能
   - 「想定と違うシステムができあがる」リスクが大幅に減少

2. **変更に強い設計が手に入る**
   - ドメインモデルを中心に機能を整理し、コンテキストごとに分割
   - 部分的な変更が全体に及ぶ影響を最小限に抑えられる

3. **チーム開発がスムーズになる**
   - ドメインごとにチームや役割を明確化
   - コードやデータベースが整理され、新メンバーの理解も容易

## 2. ユビキタス言語（Ubiquitous Language）

### 2.1 ユビキタス言語とは

**ユビキタス言語**とは、「サービスのターゲット業務や開発に関わるすべての人が、見聞きして同じ意図を連想できる一意の言葉」で、「関係者全員が同じ土俵に立つための共通認識を作るツール」です。ドメイン駆動設計において、業務知識を持つドメインエキスパートと開発者が対話する際の共通言語となります。

単なる用語集ではなく、モデルを表現する言語であり、開発チーム内での会話、コードでの表現、文書での説明など、あらゆる場面で一貫して使用されるのが特徴です。

### 2.2 ユビキタス言語の重要性

ユビキタス言語が重要な理由は以下の通りです：

1. **サービスに関わるすべての人・成果物の中で認識が揃う**
   - 認識のずれを是正するための会話が不要になる
   - 認識がずれたまま開発が進んでしまった結果の手戻りを抑えられる
   - メンバー間による、あるいは同一人物ですら起こり得る表記ゆれが激減

2. **命名の時間を節約できる**
   - コーディング時にどんな名前を付けるかは大変悩ましい問題だが、予めユビキタス言語を定義しておくことで、その言葉をコード上でも利用すればよい

3. **業務知識への理解が深まる**
   - ユビキタス言語を定義するプロセスで、業務をより深く理解できる
   - ドメインエキスパートとの会話を通じて、認識していなかったケースや背景が見えてくる

### 2.3 ユビキタス言語を定義するポイント

ユビキタス言語を定義する際のポイントは以下の通りです：

1. **全部がんばって定義する必要はない**
   - 頻繁に出てくるワードから順番に定義していく
   - 目立つもの、耳につくものから優先的に定義する

2. **意味が広義／狭義すぎる場合は適切な粒度の名前を付ける**
   - 具体的すぎる名前は広く使えない
   - 抽象度が高すぎると誤解を招く

3. **同一の呼称が複数のシーンや意味で用いられている場合は名前を分ける**
   - 文脈によって意味が異なる場合は、明確に区別する

4. **声に出して馴染むかを確認する**
   - 実際に読み上げてみて違和感がないかチェック
   - 違和感があれば、その原因を探り修正する

5. **日本語と英語、両方用意しておく**
   - コーディングでも利用しやすいように、日本語・英語どちらも定義
   - 英語にしにくい場合はローマ字表記も検討

6. **意味する業務の解説を必ず用意する**
   - 言葉が何を意味するのかの説明文は必須
   - 非日本語話者のメンバーがいる場合は特に重要

7. **ブラッシュアップを続ける**
   - 全てを最初から定義するのではなく、気づいたときに追加・修正
   - 定期的に見直し、陳腐化を防ぐ

## 3. DDDの構成要素

DDDは大きく「戦略的設計」と「戦術的設計」に分けられます。

### 3.1 戦略的設計（Strategic Design）

**戦略的設計**は、ビジネス全体を鳥瞰して、どのドメインに注力するか（コアドメインの特定）、ドメインごとにどのような境界づけを行うか（境界づけられたコンテキスト）を考えるアプローチです。

#### 3.1.1 コアドメインとサブドメイン

- **コアドメイン（Core
  Domain）**：ビジネス価値の源泉となる最重要領域。開発チームが特に注力すべき領域であり、競合他社との差別化を生む源。

- **サブドメイン（Sub
  Domain）**：コアドメインを補完するその他の領域。共通化できる部分や既存ソリューションを流用できる部分はサブドメインとして扱い、優先度を下げることが多い。

#### 3.1.2 境界づけられたコンテキスト

**境界づけられたコンテキスト（Bounded Context,
BC）**は、ドメインモデルを適用する明確な"境界"を示す概念です。システムを複数のコンテキストに分割し、各コンテキストごとにユビキタス言語を定義することで、ドメインモデルの混乱や肥大化を防ぐ狙いがあります。

#### 3.1.3 コンテキストマップ

**コンテキストマップ（Context
Map）**は、複数の境界づけられたコンテキストの関係性を示す図です。「どのコンテキストが上流・下流か」「どのような連携方式でデータをやり取りするか」「チーム間のやり取りをどうするか」を視覚的に整理します。

### 3.2 戦術的設計（Tactical Design）

**戦術的設計**は、ドメインモデルを具体的に表現するための"要素（エンティティ、値オブジェクト、ドメインサービスなど）"やルール、パターンを用いてシステムを設計する手法です。コードレベルで「ビジネスロジック」をどのように表現するかが中心課題で、細部にわたって設計・実装を行います。

#### 3.2.1 エンティティ（Entity）

**エンティティ**は、一意のIDを持ち、ライフサイクルを通して同一性を維持するドメインオブジェクトです。状態（フィールドの値）は変化しても、同じエンティティIDであれば「同一オブジェクト」として扱われます。

#### 3.2.2 値オブジェクト（Value Object）

**値オブジェクト**は、同じ属性値であれば同一とみなし、一意のIDを持たないドメインオブジェクトです。不変（Immutable）な設計を推奨し、値が変化する場合は新しい値オブジェクトとして扱うことが多いです。

#### 3.2.3 ドメインサービス（Domain Service）

**ドメインサービス**は、複数のエンティティや値オブジェクトにまたがるビジネスロジックを表すためのオブジェクトです。1つのエンティティ内部に入れにくい振る舞いや、複数のエンティティを横断して行う処理をドメインサービスとして切り出します。

#### 3.2.4 リポジトリ（Repository）

**リポジトリ**は、エンティティや集約の永続化（保存・検索・削除）を担当するパターンです。ドメイン層では「どういう操作が必要か」だけを定義し、実際のDBアクセスや外部ストレージへのやり取りはリポジトリが担うことで、ドメイン層からインフラの実装を隠蔽できます。

#### 3.2.5 ファクトリ（Factory）

**ファクトリ**は、複雑なエンティティや集約の生成ロジックをカプセル化するためのパターンです。コンストラクタで行うには複雑すぎる初期化処理や、外部サービスからの値取得などをファクトリに切り出すことで、コードの責務を明確化します。

#### 3.2.6 集約（Aggregate）

**集約**は、エンティティや値オブジェクトを一つのまとまりとして扱う単位です。集約の中には「集約ルート（ルートエンティティ）」が存在し、外部から集約にアクセスする場合、ルートエンティティを経由して操作します。集約単位で整合性（トランザクション）を保つという考え方が重要です。

#### 3.2.7 ドメインイベント（Domain Event）

**ドメインイベント**は、ドメインで重要な出来事が起きたことを表すオブジェクトです。"商品が購入された""支払いが完了した""出荷が完了した"など、ビジネス上重要なトリガーをイベントとして扱い、システム全体に伝達することができます。

## 4. 実装アプローチ

DDDの概念を実装に落とし込む際のアプローチを説明します。

### 4.1 境界づけられたコンテキストの実装

#### 4.1.1 基本的な考え方

境界づけられたコンテキストを実装する基本的な考え方は：

**1コンテキスト = 1アプリケーション**

これを基本として、用途や実装コストと相談しながら少しずつ設計を組み替える検討が可能です。

#### 4.1.2 DBの扱い

**基本的に1アプリケーション1DB**と考えるのが望ましいです。DBを共有していると：

- モジュール同士の結合度が高まる
- 「商品」などの概念について「どちらのモデルか？」という矛盾が発生
- リリースサイクルなどを独立して扱いにくくなる

同一アプリケーション内でコンテキストを分けている場合でも、少なくとも別スキーマにすることで、設計の明確化とシステム拡張時の分割のしやすさを担保できます。

#### 4.1.3 コンテキスト間の通信

コンテキスト間の通信方法は大きく分けて2種類あります：

1. **同期通信**：ネットワーク経由の直接呼び出し（REST APIなど）
2. **非同期通信**：メッセージキューを利用したイベント通信

それぞれの選択は、「リクエスト結果を同期的に取得したいか」「非同期にして先方のサービスが落ちていても大丈夫なようにしたいか」といった要件によって決まります。

### 4.2 アーキテクチャとの組み合わせ

DDDは以下のようなアーキテクチャと組み合わせることで、より効果的に実装できます：

#### 4.2.1 レイヤアーキテクチャとDIP

**レイヤアーキテクチャ**では、典型的に以下の4層に分割されます：

1. プレゼンテーション層（UI層）
2. アプリケーション層
3. ドメイン層
4. インフラ層

**DIP（依存関係逆転の原則）**を適用することで、上位レイヤは下位レイヤの実装詳細に依存しないようにします。特にドメイン層がインフラ層に依存しないようにすることが重要です。

#### 4.2.2 ヘキサゴナルアーキテクチャ

**ヘキサゴナルアーキテクチャ**（別名「ポート＆アダプタアーキテクチャ」）では、核となるドメインロジック（アプリケーションの中心）を囲むように「ポート」と「アダプタ」を配置し、あらゆる入出力（UI、DB、外部システムなど）を"アダプタ"として差し替え可能に設計します。

#### 4.2.3 CQRS

**CQRS（Command Query Responsibility
Segregation）**は、コマンド（書き込み処理）とクエリ（読み取り処理）を明確に分けて設計・実装するパターンです。書き込みモデル（Command
Model）と読み取りモデル（Query Model）が異なるデータ構造を持つことも多いです。

#### 4.2.4 イベント駆動アーキテクチャ

**イベント駆動アーキテクチャ**は、システム内で何らかの事象（イベント）が発生したときに、イベントメッセージを通知し、他のコンポーネントがそれを受け取り処理するスタイルのアーキテクチャです。DDDのドメインイベントと組み合わせることで効果的な実装が可能です。

## 5. DDDの導入ステップ

DDDを導入する際の一般的なステップは以下の通りです：

### 5.1 ユビキタス言語の構築

1. **対象の業務フローと要件を深く理解する**
   - ドメインエキスパートとの密なコミュニケーション
   - 既存のドキュメントや業務フローの分析

2. **ドメイン知識なしで思いつく単語を挙げてみる**
   - 初期段階の言語リストを作成
   - チーム内で共有し、議論のたたき台にする

3. **ドメインエキスパートと問題を分析する**
   - 挙げた単語についてドメインエキスパートと議論
   - 用語の定義や範囲を明確化

4. **ユビキタス言語を決定する**
   - 合意された定義をドキュメント化
   - チーム全体で共有し、コードやドキュメントでも一貫して使用

### 5.2 戦略的設計の実施

1. **コアドメインとサブドメインを識別する**
   - ビジネス価値の源泉となる領域を特定
   - 周辺的な機能や共通機能をサブドメインとして整理

2. **境界づけられたコンテキストを定義する**
   - ドメインモデルを適用する明確な境界を設定
   - 各コンテキスト内でのユビキタス言語を洗練

3. **コンテキストマップを作成する**
   - コンテキスト間の関係性を視覚化
   - 連携方法や依存関係を明確化

### 5.3 戦術的設計の実施

1. **ドメインモデルの構築**
   - エンティティ、値オブジェクト、集約などを特定
   - ドメインロジックを表現するモデルを作成

2. **アプリケーションサービスの設計**
   - ユースケースを実現するアプリケーション層を設計
   - ドメインモデルとの連携を整理

3. **インフラストラクチャの実装**
   - リポジトリの実装
   - 外部システムとの連携方法の決定

## 6. DDDの導入における注意点

DDDを導入する際の注意点は以下の通りです：

### 6.1 学習コストへの対応

- DDDは概念が多く、学習コストが高い
- チーム全体がDDDを理解するための時間とリソースを確保
- 段階的に導入し、徐々に理解を深めていく

### 6.2 オーバーエンジニアリングの回避

- 小規模プロジェクトや単純な要件では過剰になることも
- プロジェクトの規模や複雑さに応じて適用範囲を調整
- 必要以上に複雑な設計を避ける

### 6.3 継続的な改善

- ドメインモデルは一度作ったら終わりではなく、継続的に改善
- ビジネス要件の変化に合わせてモデルも進化させる
- 定期的にユビキタス言語やモデルを見直す

## 7. まとめ

ドメイン駆動設計（DDD）は、複雑なビジネスドメインを扱うソフトウェア開発において、ビジネスの本質に焦点を当てた設計手法です。ユビキタス言語を中心に、ビジネス担当者と開発者が共通の理解を持ち、ドメインモデルをコードに反映させることで、ビジネス要件の変化に強く、保守性の高いシステムを構築することができます。

DDDの導入は一朝一夕にはいきませんが、段階的に取り入れることで、チームのコミュニケーションや設計思想に大きな変化をもたらすことができます。特に複雑なビジネスルールを持つプロジェクトや、長期的な保守が必要なシステムでは、DDDのアプローチが大きな価値を生み出すでしょう。

## 8. 参考文献

- エリック・エヴァンス (著), 和智右桂, 牧野裕子 (翻訳), 今関剛 (監修)
  『エリック・エヴァンスのドメイン駆動設計』翔泳社, 2011年
- Vaughn Vernon (著), 高木正弘 (翻訳) 『実践ドメイン駆動設計』翔泳社, 2015年
- Jimmy Nilsson (著), 長尾高弘 (翻訳), 尾島良司 (監修) 『ドメイン駆動
  C#プログラマのためのドメイン駆動的用法』ソフトバンククリエイティブ, 2006年
- [Qiita: ふわっと理解するDDD ~~ドメイン駆動設計~~](https://qiita.com/yu-saito-ceres/items/f73262cedcdd6e8e75c8)
- [Qiita: 「ユビキタス言語」とは？ - ドメイン駆動設計の用語の理解を試みる](https://qiita.com/moromi25/items/d993700b732a7baa1c57)
- [Qiita: 境界づけられたコンテキスト 実装編 - ドメイン駆動設計用語解説](https://qiita.com/little_hand_s/items/6e65ae050b873056c50c)
- [Note: DDD(ドメイン駆動設計)の魅力と実践：AIエージェント・戦略的設計から戦術的設計まで](https://note.com/tatsuyamatsuda/n/n671ce4e03d48)
